bundle agent inventory_CVE_2016_2118
{
  meta:
    "description"
     string => "Detect and Report on badlock vulnerability.";

    "tags" slist => { "autorun" };

  vars:
    "CVE" string => "CVE-2016-2118";

    "data"
      data => readdata("$(this.promise_dirname)/data/$(sys.flavor).json", "auto"),
      unless => isvariable(data),
      comment => "We have defined the vulnerable package versions for each
		  platform we care about in this external data file, we need
		  this information so that we can identify if the system has a
                  vulnerable version installed.";

    # We need to extract a list of the versions from the loaded data so that we
    # can compare the list with the installed version of samba (if installed).
    "vulnerable_versions"
      slist => getvalues(data),
      unless => isvariable(vulnerable_versions);

    "packages"
      data => packagesmatching("samba", ".*", ".*", ".*");

  classes:

    # Note: Classes are automatically canonified when defined, but when tested
    # they must be explicitly canonified

    "$(CVE)" -> { "$(CVE)" }
      expression => reglist( @(vulnerable_versions), "$(packages[0][version])" ),
      scope => "namespace",
      comment => "We are vulnerable if the installed version of samba matches a
		  vulnerable version as defined in the external data file. We
		  define a class for the CVE so that it can be used for making
                  decisions in other parts of the policy";

  vars:

    # CFEngine Enterprise users can tag variables (or classes for that matter)
    # and augment Mission Portals Inventory reporting interface.

    enterprise_edition::

      "vulnerability" -> { "Mission Portal" }
        string => "$(CVE)",
        meta => { "inventory", "attribute_name=Vulnerable CVE(s)" },
        if => canonify( $(CVE) );

  methods:

    "Refresh Installed Software Cache"
      usebundle => refresh_software_package_cache( $(this.bundle) ),
      if => canonify( $(CVE) );

  vars:

    "DEBUG|DEBUG_$(this.bundle)"::

      "updates"
        data => packageupdatesmatching("samba", ".*", ".*", ".*");
      "u" slist => getindices(updates);

      "rpm_q_version"
        string => execresult("/bin/rpm -q samba", "noshell"),
        unless => isvariable( "rpm_q_version" );

    "yum_check_update"
        string => execresult("$(paths.yum) check-update samba", "noshell"),
        unless => isvariable( "yum_check_update" );

  reports:
      "Detected Vulnerability: $(CVE)$(const.n)"
        if => canonify( $(CVE) );

    "DEBUG|DEBUG_$(this.bundle)"::
      "$(const.t)Installed Version:
$(const.t)$(const.t)packagesmatching(): $(packages[0][version])
$(const.t)$(const.t)          `rpm -q`: $(rpm_q_version)$(const.n)";

      "$(const.t)Updates Available:
$(const.t)$(const.t)packageupdatesmatching(samba): $(updates[$(u)][version])
$(const.t)$(const.t)yum check-update samba$(const.n)$(yum_check_update)$(const.n)";
}

bundle agent remediate_CVE_2016_2118
{
  meta:
    "description"
      string => "Upgrade samba if we are vulnerable to badlock";

    remediate_CVE_2016_2118::

      "tags" slist => { "autorun" };

  packages:

    centos::

      "samba"
        policy => "present",
        version => "latest",
        package_module => yum,
        classes => results("bundle", "samba_latest"),
        action => immediate,
        if => canonify( $(inventory_CVE_2016_2118.CVE) ),
        comment => "We want to update samba to the latest version available if we
                    are vulnerable.";

  methods:

    "Refresh Installed Software Cache"
      usebundle => refresh_software_package_cache( $(this.bundle) ),
      if => canonify( $(inventory_CVE_2016_2118.CVE) );

  reports:
      "Automatically remediated $(inventory_CVE_2016_2118.CVE) by upgrading samba."
        if => canonify( $(inventory_CVE_2016_2118.CVE) );
}

bundle agent refresh_software_package_cache(caller)
# TODO Consider putting something similar into the standard library.
# TODO Clean this up to do only what's necessary.
{
  meta:
      "description" string => "Refresh cfengines internal package cache";

  packages:

      "cfe_internal_refresh_pkg_cache"
        package_policy => "add",
        package_method => refresh_yum_cache(0),
        handle => "refresh_from_$(caller)",
        action => immediate;

  files:
     "$(sys.statedir)/packages_updates_yum.*"
      handle => "refresh3_from_$(caller)",
      delete => tidy;

  commands:

      "/bin/touch"
        args => "--date=@0 $(sys.statedir)/software_packages.csv",
        handle => "refresh1_from_$(caller)",
        action => immediate,
        comment => "We touch our internal package cache so it will be
                  regenerated sooner than later";

      "/bin/touch"
        args => "--date=@0 $(sys.statedir)/software_patches_avail.csv",
        handle => "refresh2_from_$(caller)",
        action => immediate,
        comment => "We touch our internal package cache so it will be
                  regenerated sooner than later";
  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): actuated by $(caller).";
}

body package_method refresh_yum_cache(update_interval)
# TODO Remove the use of this bundle. It was part of some experimentation, I
# think other existing definitions should work to help refresh our internal
# caches.
# @depends common_knowledge redhat_knowledge rpm_knowledge
# @brief Yum+RPM installation method for inventory purposes only
# @param update_interval how often to update the package and patch list
#
# This package method is a copy of the yum_rpm method just for
# inventory purposes.
#
# It will never run "yum update" but is otherwise exactly like the
# `yum_rpm()` package method and *may* use the network to install
# packages, as Yum may decide.
{
      package_changes => "bulk";
      package_list_command => "$(rpm_knowledge.call_rpm) -qa --qf '$(rpm_knowledge.rpm3_output_format)'";
      package_patch_list_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) check-update $(redhat_knowledge.check_update_postproc)";

      package_list_name_regex    => "$(rpm_knowledge.rpm3_name_regex)";
      package_list_version_regex => "$(rpm_knowledge.rpm3_version_regex)";
      package_list_arch_regex    => "$(rpm_knowledge.rpm3_arch_regex)";

      package_installed_regex => ".*";
      package_name_convention => "$(name)-$(version).$(arch)";

      # just give the package name to rpm to delete, otherwise it gets "name.*" (from package_name_convention above)
      package_delete_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) check-update $(redhat_knowledge.check_update_postproc)";
      package_list_update_ifelapsed => $(update_interval);

      package_patch_name_regex    => "$(redhat_knowledge.patch_name_regex)";
      package_patch_version_regex => "$(redhat_knowledge.patch_version_regex)";
      package_patch_arch_regex    => "$(redhat_knowledge.patch_arch_regex)";

      package_add_command    => "$(redhat_knowledge.call_yum) --help >/dev/null 2>&1 ; /bin/true";
      package_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
      package_patch_command  => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
      package_delete_command => "$(rpm_knowledge.call_rpm) -e --nodeps";
      package_verify_command => "$(rpm_knowledge.call_rpm) -V";
}
